name: Build and Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build and Publish Windows
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: npm run electron:publish:win

  update-release-notes:
    needs: release
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        uses: actions/github-script@v7
        with:
          script: |
            const tag = context.ref.replace('refs/tags/', '');

            // Get release
            const { data: release } = await github.rest.repos.getReleaseByTag({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag: tag
            });

            // Get commits since last tag
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 5
            });

            let baseTag = 'HEAD~10';
            if (tags.length > 1) {
              baseTag = tags[1].name;
            }

            try {
              const { data: comparison } = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: baseTag,
                head: tag
              });

              const features = [];
              const fixes = [];
              const others = [];

              for (const commit of comparison.commits) {
                const msg = commit.commit.message.split('\n')[0];
                if (msg.toLowerCase().includes('feat') || msg.toLowerCase().includes('add')) {
                  features.push(`- ${msg}`);
                } else if (msg.toLowerCase().includes('fix')) {
                  fixes.push(`- ${msg}`);
                } else if (!msg.includes('Merge') && !msg.includes('release') && msg.length > 3) {
                  others.push(`- ${msg}`);
                }
              }

              let notes = '';
              if (features.length > 0) {
                notes += '## 새로운 기능\n' + features.join('\n') + '\n\n';
              }
              if (fixes.length > 0) {
                notes += '## 버그 수정\n' + fixes.join('\n') + '\n\n';
              }
              if (others.length > 0) {
                notes += '## 기타 변경사항\n' + others.join('\n') + '\n\n';
              }

              if (notes === '') {
                notes = '버전 ' + tag + ' 릴리즈';
              }

              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                body: notes
              });

              console.log('Release notes updated!');
            } catch (e) {
              console.log('Could not generate notes:', e.message);
            }
